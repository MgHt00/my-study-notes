This concept refers to something called **"lexical scoping"** or **"closure"** in JavaScript. It means that when a function is defined, it remembers the scope (the variables and functions it has access to) at the point where it was created. Even if the function is invoked later in a different scope, it will still use the scope it had when it was defined, not the scope that exists when it's called.

Here’s a breakdown with an example:

### Example:
```javascript
function outer() {
    let x = 10;

    function inner() {
        console.log(x); // Accesses 'x' from the outer scope
    }

    return inner;
}

let myInnerFunc = outer(); // 'outer' is invoked, returning the 'inner' function
myInnerFunc(); // Logs 10, even though 'outer' has already finished executing
```

### Explanation:
1. **Definition of `outer()`**: When the `outer()` function is defined, it creates a variable `x` inside its scope and defines the `inner()` function.
   
2. **Definition of `inner()`**: The `inner()` function has access to `x` because it was defined inside `outer()`. This is lexical scoping—`inner()` can "see" the variables in its outer scope (i.e., the scope where it was defined).

3. **Invocation of `outer()`**: When you invoke `outer()`, it returns the `inner()` function but doesn't immediately execute it.

4. **Later invocation of `inner()`**: Even though `outer()` has finished executing by the time you call `myInnerFunc()`, the function `inner()` still "remembers" the scope where it was defined (i.e., the `x = 10` in `outer()`), and so it logs `10`.

### Key takeaway:
- When a function is defined, it captures the variables in the scope where it was created.
- Even if you invoke the function later, in a completely different scope, the function will still use the variables from its original scope.

This behavior allows JavaScript functions to **"remember"** the environment they were created in. This is the power of closures!

---

The continuing statement is talking about the internal workings of **closures** in JavaScript, which is what makes lexical scoping work.

### Breakdown of the Statement:
1. **Lexical scoping implementation**:
   - Lexical scoping means that a function can access variables from the scope where it was defined, not where it is invoked.
   - To achieve this, JavaScript functions must store more than just their code when they are created.

2. **Function object and its internal state**:
   - When a function is created in JavaScript, it's not just a set of instructions or code.
   - Internally, it **remembers** the surrounding scope (or environment) where it was defined. This scope includes all the variables that were in scope at the time of the function’s creation.

3. **What is a closure?**:
   - A **closure** is the combination of:
     1. The **function object** itself (i.e., the code).
     2. The **scope/environment** where the function was created (i.e., a reference to all the variables that were accessible when the function was defined).
   - This combination allows the function to remember its lexical scope, even if it is invoked in a different scope later on.

### Example to Illustrate:

```javascript
function outer() {
    let count = 0; // A variable inside outer's scope

    function increment() {
        count++;  // Accesses the 'count' variable from the outer scope
        console.log(count);
    }

    return increment;
}

let myIncrement = outer();  // outer() returns the increment function
myIncrement();  // Logs 1
myIncrement();  // Logs 2
```

### Explanation:
1. **Function creation and scope reference**: 
   - When `increment()` is defined inside `outer()`, it captures the `count` variable from the `outer()` scope.
   - Even though `outer()` has finished running, the `increment()` function **still remembers** the `count` variable. This is because `increment()` forms a **closure** that includes the function code and the surrounding scope (which contains `count`).

2. **How closures work**:
   - The `myIncrement()` function keeps accessing and modifying the `count` variable even though `outer()` has already executed and gone out of scope. The variable `count` is "remembered" because the closure keeps a reference to the scope where `increment()` was created.

3. **The closure includes a reference to the scope**:
   - When `outer()` returns `increment()`, it doesn't just return the function code, it also returns the **closure**, which contains both the code of `increment()` and the reference to the `count` variable from the `outer()` scope.

### Summary:
- When a function is created, JavaScript attaches not only the function's code but also a **reference** to the surrounding variables (scope).
- This combination of the function and the scope is called a **closure**.
- Closures allow functions to "remember" the environment in which they were created, even if they are called later in a different context.

This is a powerful feature in JavaScript, enabling you to create **persistent state** within functions, modularize code, and avoid polluting the global namespace.